# Define a ordem de execu√ß√£o dos est√°gios
stages:
  - build
  - deploy

# EST√ÅGIO 1: Construir a imagem Docker e enviar para o Registry
build_image:
  stage: build
  tags:
    - vps # O runner precisa ter a tag 'vps' e estar configurado com o executor Docker
  
  # Usamos uma imagem Docker que j√° vem com as ferramentas do Docker
  # e um servi√ßo 'docker-in-docker' para permitir a constru√ß√£o de imagens.
  image: docker:20.10.16
  services:
    - docker:20.10.16-dind
  
  script:
    - echo "Fazendo login no GitLab Container Registry..."
    # $CI_REGISTRY_USER e $CI_JOB_TOKEN s√£o vari√°veis seguras fornecidas pelo GitLab
    - docker login -u $CI_REGISTRY_USER -p $CI_JOB_TOKEN $CI_REGISTRY

    - echo "Construindo a imagem Docker..."
    # Criamos uma tag √∫nica para a imagem usando o ID curto do commit (ex: a1b2c3d4)
    # $CI_REGISTRY_IMAGE √© uma vari√°vel que aponta para o seu registry (ex: registry.gitlab.com/seu-usuario/cashpilot)
    - docker build -t "$CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA" .

    - echo "Enviando a imagem para o Registry..."
    - docker push "$CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA"

# EST√ÅGIO 2: Fazer o deploy da imagem no servidor VPS
deploy_production:
  stage: deploy
  tags:
    - vps # Garanta que seu runner tenha essa tag
  
  # A URL do ambiente agora tamb√©m √© din√¢mica!
  environment:
    name: production
    url: https://$CI_PROJECT_NAME.$DOMAIN_NAME

  script: |
      # --- COMANDO M√ÅGICO PARA CAPTURAR ERROS ---
      set -e

      echo "Iniciando deploy para o projeto: $CI_PROJECT_NAME"
      
      # Configura√ß√£o do SSH
      which ssh-agent || ( apt-get update -y && apt-get install openssh-client -y )
      eval $(ssh-agent -s)
      ssh-add <(echo "$SSH_PRIVATE_KEY")
      mkdir -p ~/.ssh && chmod 700 ~/.ssh
      ssh-keyscan $VPS_IP >> ~/.ssh/known_hosts && chmod 644 ~/.ssh/known_hosts
      ssh $VPS_USER@$VPS_IP "
        # 1. Passa as vari√°veis do GitLab para a sess√£o SSH remota
        export CI_PROJECT_NAME=${CI_PROJECT_NAME}
        export CI_SERVER_HOST=${CI_SERVER_HOST}
        export CI_PROJECT_PATH=${CI_PROJECT_PATH}
        export DOMAIN_NAME=${DOMAIN_NAME}
        
        # 2. Constr√≥i os nomes dinamicamente no servidor
        TARGET_DIR=~/docker-stacks/\$CI_PROJECT_NAME
        REPO_URL=git@\$CI_SERVER_HOST:\$CI_PROJECT_PATH.git
        
        echo \"üöÄ Deploying project: \$CI_PROJECT_NAME\"
        echo \"Target directory: \$TARGET_DIR\"
        echo \"Repository URL: \$REPO_URL\"
        
        # L√≥gica para clonar ou atualizar o reposit√≥rio
        if [ -d \"\$TARGET_DIR\" ]; then
          echo '‚úÖ Diret√≥rio existente. Atualizando...'
          cd \"\$TARGET_DIR\"
          git pull origin main
        else
          echo 'ü§î Diret√≥rio n√£o encontrado. Clonando o reposit√≥rio...'
          git clone \"\$REPO_URL\" \"\$TARGET_DIR\"
          cd \"\$TARGET_DIR\"
        fi
        
        echo '--- üìù Criando arquivo de configura√ß√£o .env.prod ---'
        # Este bloco continua o mesmo, ele j√° usa as vari√°veis do GitLab
        echo \"DATABASE_URL=${DATABASE_URL}\" > .env.prod
        echo \"DJANGO_SECRET_KEY=${DJANGO_SECRET_KEY}\" >> .env.prod
        echo \"DEBUG=${DEBUG}\" >> .env.prod
        echo \"DOMAIN_NAME=${DOMAIN_NAME}\" >> .env.prod
        # ===============================================
        
        echo '--- üîë Autenticando no GitLab Registry ---'
        docker login -u \"${DEPLOY_TOKEN_USER}\" -p \"${DEPLOY_TOKEN_PASSWORD}\" $CI_REGISTRY
    

        echo '--- üê≥ Fazendo deploy com Docker Compose ---'
        export CI_REGISTRY_IMAGE=$CI_REGISTRY_IMAGE
        export IMAGE_VERSION=$CI_COMMIT_SHORT_SHA
        
        # ---- L√ìGICA BLUE-GREEN ----

        # 1. Determina qual √© a cor atual e qual ser√° a pr√≥xima
        if \$(docker ps --format '{{.Names}}' | grep -q \"\${CI_PROJECT_NAME}_blue\"); then
            CURRENT_COLOR=\"blue\"
            NEXT_COLOR=\"green\"
        else
            CURRENT_COLOR=\"green\" # Assume green como default se nenhum estiver rodando
            NEXT_COLOR=\"blue\"
        fi
        
        echo \"üöÄ Vers√£o atual: \$CURRENT_COLOR. Pr√≥xima vers√£o: \$NEXT_COLOR\"
        # 2. Sobe o novo ambiente (ex: green)
        # A flag '-p' cria um 'projeto' Docker Compose separado, evitando conflitos.
        echo \"--- ‚¨ÜÔ∏è  Iniciando a nova vers√£o (\$NEXT_COLOR) --- \"
        docker compose -p \${CI_PROJECT_NAME}_\${NEXT_COLOR} pull
        docker compose -p \${CI_PROJECT_NAME}_\${NEXT_COLOR} up -d --remove-orphans

        # 3. VERIFICA√á√ÉO DE SA√öDE COM L√ìGICA DE ROLLBACK
        echo \"--- ü©∫ Aguardando a nova vers√£o ficar online e saud√°vel... --- \"
        HEALTH_CHECK_URL=\"https://\${CI_PROJECT_NAME}.$DOMAIN_NAME\"
        
        n=0
        HEALTHY=false
        until [ \"\$n\" -ge 10 ]
        do
          if curl -s -f -k \"\$HEALTH_CHECK_URL\" > /dev/null; then
            echo \"‚úÖ Aplica√ß√£o online e respondendo com sucesso!\"
            HEALTHY=true
            break
          fi
          
          n=\$((n+1)) 
          echo \"Tentativa \$n/10 falhou. Aguardando 6 segundos...\"
          sleep 6
        done

        # =========================================================================
        # 4. DECIS√ÉO FINAL: PROSSEGUIR COM O DEPLOY OU FAZER ROLLBACK
        # =========================================================================
        if [ \"\$HEALTHY\" = true ]; then
          # Health Check PASSOU: a nova vers√£o est√° boa.
          # Removemos a vers√£o antiga e declaramos vit√≥ria.
          echo \"--- üëç Health check bem-sucedido. Finalizando o deploy. --- \"
          if [ \"\$CURRENT_COLOR\" != \"\$NEXT_COLOR\" ] && \$(docker ps --format '{{.Names}}' | grep -q \"\${CI_PROJECT_NAME}_\${CURRENT_COLOR}\"); then
              echo \"--- ‚¨áÔ∏è  Removendo a vers√£o antiga (\$CURRENT_COLOR) --- \"
              docker compose -p \${CI_PROJECT_NAME}_\${CURRENT_COLOR} down
          fi
          echo \"üéâ Deploy sem downtime conclu√≠do! Vers√£o \$NEXT_COLOR est√° no ar.\"
        else
          # Health Check FALHOU: a nova vers√£o est√° com problema.
          # Fazemos o rollback e falhamos o pipeline.
          echo \"‚ùå A nova vers√£o n√£o respondeu corretamente. Iniciando rollback autom√°tico...\"
          
          echo \"--- Logs da vers√£o que falhou (\$NEXT_COLOR) para depura√ß√£o --- \"
          docker compose -p \${CI_PROJECT_NAME}_\${NEXT_COLOR} logs
          
          echo \"--- ‚¨áÔ∏è  Derrubando a nova vers√£o que falhou (\$NEXT_COLOR) --- \"
          docker compose -p \${CI_PROJECT_NAME}_\${NEXT_COLOR} down
          
          echo \"‚úÖ Rollback conclu√≠do. A vers√£o antiga (\$CURRENT_COLOR) continua no ar, intocada.\"
          
          # Falha o pipeline explicitamente
          exit 1
        fi

      "
  only:
    - main
